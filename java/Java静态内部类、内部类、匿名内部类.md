
## Java内部类(InnerClass)----静态内部类、成员内部类、方法内部类、匿名内部类
Java进阶知识系列文章：
>[Java进阶知识 —— 算法复杂度o(1), o(n), o(logn), o(nlogn)](https://blog.csdn.net/dazhaoDai/article/details/81631195)
>[Java进阶知识 —— 垃圾回收机制](https://blog.csdn.net/dazhaoDai/article/details/81182396)
>[Java进阶知识 —— 快速排序算法分析](https://blog.csdn.net/dazhaoDai/article/details/80245908)
>[Java进阶知识 —— 算法时间复杂度](https://blog.csdn.net/dazhaoDai/article/details/80191371)
>
#### 1.什么是内部类
面向对象程序设计中，可以在一个类的内部定义另一个类。内部类分为两种，即静态内部类和非静态内部类。非静态内部类又分为成员内部类，方法内部类、匿名内部类

#### 2.为什么使用内部类
⒈ 内部类对象可以访问创建它的对象的实现，包括私有数据；
⒉ 内部类不为同一包的其他类所见，具有很好的封装性；
⒊ 使用内部类可以很方便的编写事件驱动程序；
⒋ 匿名内部类可以方便的定义运行时回调；
5.内部类可以方便的定义
每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。


#### 3.几种内部类的区别
##### 3.1 静态内部类

和普通类一样，内部类也可以由静态的。不过和非静态内部类相比，区别就在于<font color=#ff0000 >静态内部类没有了指向外部类的引用</font>。除此之外，在任何非静态内部类中，都不能有静态数据，静态方法或者又一个静态内部类（内部类的嵌套可以不只一层）。不过静态内部类中可以拥有者一切。这也算俩者的第二个区别吧。

##### 3.2 成员内部类

<font color=#ff0000 >成员内部类和静态内部类可以类比为非静态的成员变量和静态的成员变量,注意在创建非静态内部类对象时，一定要先创建起相应的外部类对象</font>
作为外部类的一个成员存在，与外部类的属性、方法并列,它可以访问它的外部类的所有成员变量和方法，不管是静态的还是非静态的都可以。
例如：

```
public class A{
    private int age = 100
    private String name = "aaa"
    
    //成员内部类
    //不对外开放，高内聚
    class B{
      public String showName(){  //内部类访问外部类变量
          return A.this.name
      }
    }
}

public class C{
    public static void main(String[] args) {
         B b = new A().new B()
         b.showName()
     }
}
```
##### 3.3 方法内部类

定义在方法中，比方法的范围还小。是内部类中最少用到的一种类型。
像局部变量一样，不能被public, protected, private和static修饰。
只能访问方法中定义的final类型的局部变量。
方法内部类在方法中定义，所以只能在方法中使用，即只能在方法当中生成方法内部类的实例并且调用其方法

```
public class TestInnerClass {

	int a = 0;
	class A {
		public String showName() {
			return "";
		}
	}

	public void go() {
		final String name = "afa"; //方法内的变量只有final变量才能被方法内部类访问
		class B extends A {
			public String getName() {
				return name + "aa";
			}
		}
		B b = new B();
		b.getName();
	}
}
```
方法中的内部类访问方法中的局部变量为什么要加final?
><font color=#ff0000 >内部类的生命周期和方法中的局部变量是不一样的，内部类是也是一个类，是存储在堆中，也只有当对该类的引用消失时，内部类才会消亡。而方法的局部变量是存储在堆栈中的，当调用结束时就会退栈，即在内存中这个属性就消失了。也就是说，内部类的生命周期超过了方法中局部变量的生命周期，内部类可能会调用到已经消失的属性，因此内部类不能访问方法中的局部变量。 解决方法就是在局部变量前加修饰符final ，此时局部变量就会存在堆中，生命周期跟工程的生命周期是一样的，此时内部类就可以访问方法中的局部变量。</font>

##### 3.4 匿名内部类（Android运用最多）

匿名内部类就是没有名字的局部内部类，不使用关键字class, extends, implements, 没有构造方法。
什么情况下需要使用匿名内部类？如果满足下面的一些条件，使用匿名内部类是比较合适的：

- a·只用到类的一个实例。
- b·类在定义后马上用到。
- c·类非常小（SUN推荐是在4行代码以下）
- d·给类命名并不会导致你的代码更容易被理解。

在使用匿名内部类时，要记住以下几个原则：

- a·匿名内部类不能有构造方法。
- b·匿名内部类不能定义任何静态成员、方法和类。
- c·匿名内部类不能是public,protected,private,static。
- d·只能创建匿名内部类的一个实例。
- e·一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。
- f·因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。

​    

#### 参考

--------
https://www.cnblogs.com/lgk1002/p/6069784.html

-------